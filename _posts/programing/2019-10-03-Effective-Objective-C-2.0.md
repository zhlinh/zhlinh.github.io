---
layout: article
title:  "Effective Objective-C 2.0"
categories: programing
tags: [objective-c, oc, reading]
toc: false
image:
    teaser: programing/2019-10-03-Effective-Objective-C-2.0/teaser.jpg

date: 2019-10-03
---

由于一直在维护项目中Android和iOS的C++跨平台代码，因此除了Android还需要在iOS上进行调试和定位问题，
所以最近在学习Objective-C。学习无外乎框架学习法、三遍学习法和费曼学习法，此次记录勉强算作烂笔头吧。
感觉Objective-C比Java还要动态，此外GCD的使用也很方便。

---

## 1 了解Objective-C的起源

1. Objective-C为C语言添加了面向对象的特性，是其超集。Objective-C使用动态绑定的消息结构
2. 理解C语言的核心概念有助于写好Objective-C。尤其是内存模型和指针

## 2 在类的头文件中尽量少引入其他头文件

1. 除非确实有必要，否则不要引入头文件。可以使用前向声明，降低耦合
2. 若无法使用前向声明，如协议。则尽量将协议移至"class-continuation"分类中。
  或者将协议放到单独的头文件中

## 3 多用字面量语法，少用与之等价的方法

1. 应该使用字面量语法来创建字符串、数值、数组、字典。更简明扼要
2. 应该通过取下标的操作来访问数组下标或字典中的键值
3. 用字面量语法创建数组或字典时，若值中有nil，则会抛出异常

## 4 多用类型常量，少用#define预处理命令

1. 不要用预处理指令定义常量，因其不含类型信息，也可能被其他人重新定义
2. 在实现文件中使用static const来定义只在该编译单元可见的变量，
  不会出现在全局符号表中
3. 在头文件中使用extern来声明全局变量，并在相关的实现文件中定义其值，
  这种变量会出现在全局符号表中，需要添加类名作前缀

## 5 用枚举表示状态、选项、状态码

1. 应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，
  给这些值起个易懂的名字
2. 如果是多个选项可同时使用可以使用位运算，值定义为2的幂
3. 用NS_ENUM和NS_OPTIONS宏来定义枚举类型，并指明底层数据类型。
  这样可以确保枚举是用开发者所选的底层数据类型实现出来的
4. 在处理枚举类型的switch语句中不要出现default分支，这样的话，
  加入新枚举之后编译器会提醒开发者：switch语句并未处理所有枚举

## 6 理解属性这一概念

1. 可以用@property语法来定义对象中所封装的数据
2. 通过"特质"来指定存储数据所需的正确语义，如atomic/nonatomic，
  readwrite/readonly，assign/strong/weak/unsafe_unretained/copy，
  getter=<name>/setter=<name>
3. 在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义
4. 开发iOS程序时应该使用nonatomic属性，因为atomic属性会严重影响性能

## 7 在对象内部尽量直接访问实例对象

1. 在对象内部读应该直接通过实例变量，写应该通过属性
2. 在初始化方法及dealloc方法中，应该通过实例变量来读写
3. 对于使用惰性初始化的数据，应该通过属性来读取数据

## 8 理解对象等同性这一概念

1. 若想检测对象的等同性，请提供"isEqual"与"hash"方法
2. 等同的对象必须有相同的hash方法，但相同hash的两个对象不一定等同
3. 不要盲目地检测每条属性，而是根据需求检查所需属性
4. 写hash方法时，应该使用计算速度快且哈希码碰撞几率低的算法

## 9 以"类族"信息隐藏实现细节

1. 类族信息可以把实现细节隐藏在一套简单的公共接口后面
2. 系统框架中经常使用类族
3. 从类族的公共抽象基类中继承子类时需要当心，若有开发文档，则应首先阅读

## 10 在既有类中使用关联对象存放自定义数据

1. 可以通过"关联对象"机制把两个对象关联起来
2. 定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的
  "拥有关系"与"非拥有关系"
3. 只有在其他方法不可行的时候才使用关联对象，因为这种做法可能会造成"保留环"
  问题，引入难以查找的bug

## 11 理解objc_msgSend的作用

1. 消息由接收者，选择子（即方法名）和参数构成。给某对象发送消息也就是在
  该对象上调用方法
2. 发给某对象的全部消息都要由动态消息派发系统来处理，该系统会查出相应的方法，
  并执行其代码

## 12 理解消息转发机制

1. 若对象无法响应某个选择子，则进入消息转发流程
2. 通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中
3. 对象可以把其无法解读的某些选择子转交给其他对象来处理
4. 经过上述两步后，如果还是没办法处理选择子，那就启动完整的消息转发机制

## 13 用方法调配技术调试黑盒方法

1. 在运行期，可以向类中新增或替换选择子对应的方法实现
2. 使用另一份实现来替换原有的方法实现，这个叫做方法调配，
  开发者常用此技术想原有实现中增加新功能
3. 一般来说，只有调试程序的时候才需要在运行期修改方法实现，
  这种方法不宜滥用

## 14 理解类对象的用意

1. 每个实例都有一个指向Class对象的指针，用以表明其类型，而这些Class对象则
  构成了类的继承体系
2. 如果对象类型无法在编译器确定，那么就应该使用类型信息查询方法
  (isKindOfClass或isMemberOfClass)获知
3. 尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些
  对象(NSProxy)可能实现了消息转发功能

## 15 用前缀避免命名空间冲突

1. 选择与你的公司、应用程序或二者皆有关联的名称作为类名的前缀，
   并在所有代码中均使用这一前缀
2. 若自己所开发的程序库中用到了第三方库，则应为其中的名称加上前缀

## 16 提供全能初始化方法

1. 在类中提供一个全能初始化方法，并于文档中指明。其他初始化方法均应
   调用此方法
2. 若全能初始化方法与超类不同，则需覆写超类中的对应方法
3. 如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，
   并在其中抛出异常

## 17 实现description方法

1. 实现description方法返回一个有意义的字符串，用以描述该实例
2. 若想在调试时打印出更详细的对象调试信息，则应实现debugDescription方法

## 18 尽量使用不可变对象

1. 尽量创建不可变的对象
2. 若某属性仅用可用于对象内部修改，则在"class-continuation分类"中将
   其由readonly属性扩展为readwrite属性
3. 不要把可变容器作为属性公开，而应提供相关方法来修改对象中的
   可变容器

## 19 使用清晰而协调的命名方式

1. 起名时应遵从标准的Objective-C命名规范，易于理解
2. 方法名要言简意赅，从左至右读起来像日常用语中的句子较好
3. 方法名中不要使用缩略后的类型名称
4. 给方法起名时第一要务是确保其风格与自己代码或所集成的框架相符

## 20 为私有方法名加前缀

1. 给私有方法的名称加上前缀，这样可以容易地将其与公共方法区分开
2. 不要单用一个下划线做私有方法的前缀，因为这种做法是预留给苹果公司使用的

## 21 理解Objective-C的错误模型

1. 只有发生了可使整个应用程序崩溃的严重错误时，才应使用异常
2. 在错误不那么严重的情况下，可以指派"委托方法"来处理错误，
   也可以把错误信息放在NSError对象里，经由"输出参数"返回给调用者

## 22 理解NSCopying协议

1. 若想令自己所写的拷贝对象具有拷贝功能，则需实现NSCoping协议
2. 如果自定义的对象了分为可变版本和不可变版本，那么应该同时实现NSCoping和NSMutableCopying协议
3. 复制对象时需决定采用浅拷贝还是深拷贝，一般情况下应该尽量执行浅拷贝
4. 如果你写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法

## 23 通过委托与数据源协议进行数据通信

1. 委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象
2. 将委托对象应该支持支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法
3. 当某对象需要从另外一个对象中获取数据时，可以使用委托模式。这种情境下，该模式
   亦称为"数据源协议(data source protocal)"
4. 若有必要，可实现含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存起来

## 24 将类的实现代码分散到便于管理的数个分类之中

1. 使用分类机制把类的实现代码划分成易于管理的小块
2. 将应该视为"私有"的方法归入名为Private的分类中，以隐藏实现细节

## 25 总是为第三方类的分类名称加前缀

1. 向第三方类中添加分类时，总应给其名称加上你专用的前缀
2. 向第三方类中添加分类时，总应给其中的方法名加上你专用的前缀

## 26 勿在分类中声明属性

1. 把封装数据所用的全部属性都定义在主接口中
2. 在"class-continuation分类"之外的其他分类中，可以定义存取方法，但尽量不要定义属性

## 27 使用"class-continuation分类"隐藏实现细节

1. 通过"class-continuation分类"向类新增实例变量
2. 如果某属性在主接口中声明为"只读"，而类的内部又要用设置方法修改此属性，
   那么就在"class-continuation分类"中将其扩展为可读写
3. 将私有方法的原型声明放到"class-continuation分类"中
4. 若想隐藏类所遵守的协议，则可在"class-continuatin分类"中声明

## 28 通过协议提供匿名对象

1. 协议可在某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某协议的id类型，协议里
  规定了对象所应实现的方法
2. 使用匿名对象来隐藏类型名称(或类名)
3. 如果具体类型不重要，重要的是对象能够响应协议中的特定方法，那么可以用匿名对象标识

## 29 理解引用计数

1. 引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1.
  若保留计数为正，则对象继续存活。当保留计数降为0时，对象就被销毁了
2. 在对象的生命期中，其余对象通过引用来保留或释放此计数。保留与释放操作分别会递增及递减保留计

## 30 以ARC简化引用计数

1. 有ARC之后，程序员就无需担心内存管理问题了。可省去类中的很多样板代码
2. ARC管理对象生命期的办法基本上就是在合适的地方插入保留(retain)和释放操作(release),
  在ARC环境下，变量的内存管理语义可以吃通过修饰符声明
3. 由方法所返回的对象，其内存管理语义总是通过方法名来体现，ARC将此确定为开发者必须遵守的规则
4. ARC只负责Objective-C对象的内存。如CoreFoundation对象不归ARC管理

## 31 在dealloc方法中只释放引用并解除监听

1. 在dealloc方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的键值观察(KVO)
  或NSNotificatiionCenter等通知，不要做其他事情
2. 如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放该资源。这样的类应该
  和其使用者约定：用完资源后必须调用close方法
3. 执行异步任务的方法不应在dealloc里调用；只能在正常状态下执行的方法也不应该在dealloc中调用，
  因为此时对象已处于正在回收的阶段了

## 32 编写"异常安全代码"时留意内存管理的问题

1. 捕获异常时，一定要注意将try块内所创立的对象清理干净
2. 在默认情况下，ARC不生成安全处理异常所需的清理代码。开启-fobjc-arc-exceptions编译器标志后，
  可自动生成清理代码，不过回导致应用程序变大，且会降低运行效率

## 33 以弱引用避免保留环

1. 将某些引用设为weak，可避免出现保留环
2. weak引用可以自动清空，也可以不自动清空，自动清空是随着ARC而引入的新特性，由运行期系统来实现。
  在具备自动清空功能的弱引用上，可以随意读取其特性，因为这种引用不会指向已经回收过的对象

## 34 以自动释放池块降低内存峰值

1. 自动释放池排布在栈中，对象收到autorelease消息后，系统将放入最顶端的池里
2. 合理运用自动释放池，可降低应用程序的内存峰值
3. @autoreleasepool这种新式写法能创建出更为轻便的自动释放池

## 35 用僵尸对象调试内存管理问题

1. 系统在回收对象时，可以不将其真正释放，而是把它转化为僵尸对象。通过环境变量NSZombieEnabled
  可开启此功能
2. 系统会修改对象的isa指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸对象能够响应
  所有的选择子，响应方式为"打印一条包含消息内容及接收者，然后终止程序"

## 36 不要使用retainCount

1. 对象的保留计数看似有用，实则不然。因为任何给定时间点上的绝对保留计数都无法反应对象
  生命周期的全貌
2. 引入ARC之后，retainCount方法就正式废止了，在ARC下调用该方法会导致编译器报错

## 37 理解"块"这一概念

1. 块是C、C++、Objective-C中的词法闭包
2. 块可接受参数，也可返回值
3. 块可以分配在栈或堆上，也可以是全局的。分配在栈上的块可拷贝到堆里，这样的话，
  就和标准的Objective-C对象一样，具备引用计数了

## 38 为常用的块类型创建typedef

1. 以typedef重新定义块类型，可令块变量用起来更加简单
2. 定义新类型时应遵从现有的命名习惯，勿使其名称与别的类型相冲突
3. 不妨为同一个块签名定义多个类型别名。如果要重构的代码使用了块类型的某个别名，
  只需修改相应typedef的块签名即可，无需改动其他的typedef

## 39 用hendler块降低代码分散程度

1. 在创建对象时，可以使用内联的handler块将相关业务逻辑一并声明
2. 在有多个实例需要监控时如果采用委托模式那么经常需要根据传入的对象来切换，
  若改为handler块实现，则可直接将块和相关对象放在一起
3. 设计API时如果用到了handler块，那么可以增加一个参数，
  使调用者可通过此参数来决定应该把块安排在哪个队列上执行

## 40 用块引用其所属对象时不要出现保留环

1. 如果块所捕获的对象直接或间接地保留了块本身，那么就得小心保留环的问题
2. 一定要找一个合适的时机来解除保留环，如回调后不再保留handler块对象，而不能把
  责任推给API的调用者

## 41 多用派发队列，少用同步锁

1. 派发队列可用来表述同步语义，这种做法比用@synchronized块或NSLock对象更简单
2. 将同步与异步派发结合起来，可以实现与普通加锁一样的同步行为，而这么做却不会阻塞异步派发的线程
3. 使用同步队列和栅栏块，可以令同步行为更高效

## 42 多用GCD，少用perfromSelector系列方法

1. performSelector系列方法在内存管理方面容易有疏忽。它无法确定将要执行的选择子的具体内容，
  银耳ARC编译器也就无法插入适当的内存管理方法
2. performSelector系列方法song处理的选择子太过局限了，选择子的返回类型和参数个数都受限制
3. 如果想把任务放到另一个线程上执行，最好不要用performSelector系列方法，而应该
  把任务封装在块，然后调用GCD（中枢派发机制）的相关方法实现

## 43 掌握GCD及操作队列的使用时机

1. 在解决多线程与任务管理问题时，派发队列并非唯一方案
2. 操作队列提供了一套高层的Objective-C API，能实现GCD所具备的绝大部分功能，
  而且还能完成一些更复杂的操作，而GCD则需另外编写代码

## 44 通过Dispatch Group机制，根据系统资源状况来执行任务

1. 一系列的任务可归入一个dispatch group之中。开发者可以在这组任务执行完毕时获得通知
2. 通过dispatch group可以在并发派发队列中同时执行多项任务。此时GCD会根据系统资源状况
  来调度这些并发执行的任务。

## 45 使用dispatch_once来执行只需运行一次的线程安全代码

1. 只需执行一次的线程安全代码通过GCD提供的dispatch_once函数就可以很容易实现
2. dispatch_once传入的标记应该声明在static或global作用域中，保证传入的标记相同

## 46 不要使用dispatch_get_current_queue

1. dispatch_get_current_queue函数行为常常与开发者所预期的不同，因为queue可以嵌套使用。
  此函数已经废弃，只应作调试用
2. 由于派发队列是按层级来组织的，所以无法单用某个队列对象来描述当前队列这一概念
3. dispatch_get_current_queue函数尝试解决不可重入的代码所引发的死锁问题，该问题的
  正确解法应该为dispatch_queue_set_specific，因为队列特定数据可以继承（或者说会向上层查找）

## 47 熟悉系统框架

1. 许多系统框架都可以直接使用。其中最重要的是Foundation与CoreFoundation，这两个框架
  为构建应用程序提供了许多核心功能
2. 很多常见任务都可以用框架来做，如音频与视频处理，网络通信和数据库管理等
3. 请记住：用纯C写成的框架和用Objective-C写成的一样重要，应该掌握C语言的核心概念

## 48 多用块枚举，少用for循环

1. 遍历collection容器有四种方式。最基本的是for循环，其次是NSEnumerator遍历法及快速遍历法，
  最新、最先进的方式则是块枚举法
2. 块枚举法本身就能通过GCD来并发执行遍历操作，无需另写代码，而采用其他遍历方式则无法轻易实现
  这一点
3. 若提前知道待遍历的collection容器含有何种对象，则应修改块签名，指出对象的具体类型，
  以便在编译期及时发现问题

## 49 对自定义其内存管理语义的collection使用无缝桥接

1. 通过无缝桥接技术，可以在Foundation框架中的Objective-C对象与CoreFoundation框架中的C结构体
  之间自由切换
2. 在CoreFoundation层面创建collection时，可以指定多个回调函数，这些函数表示此collection应
  如何处理其元素。然后运用无缝桥接技术，将其转成具备特殊内存管理语义的Objective-C的collection

## 50 构建缓存时选用NSCache而非NSDictionary

1. 实现缓存时应选用NSCache而非NSDictionary对象。因为NSCache可以提供优雅的自动删除功能，而且
  是线程安全的，此外它与字典不同，不会拷贝值
2. 可以给NSCache对象设置上限，用以限制缓存中的对象总个数及总成本，而这些尺度则定义了缓存删除
  其中对象的时机。但是绝对不要把这些尺度当成可靠的绝对限制，它们仅对NSCache起指导作用
3. 将NSPurgeableData与NSCache搭配使用，可实现自动清除数据的功能，也就是说，当NSPurgeableData
  所占内存被系统丢弃时，该对象也会从NSCache中清除
4. 如果缓存使用得当，那么应用程序的响应速度就能提高。只有那种重新计算起来很费事的数据，才值得
  加入缓存，比如那些需要从网络或磁盘获取的数据

## 51 精简initialize与load的实现代码

1. 在加载阶段，如果类实现了load方法，那么系统就会调用它。分类里也可以定义此方法，类的load方法
  要比分类中的先调用。与其他方法不同，load方法不参与覆写/继承机制
2. 首次使用某个类之前，系统会向其发送initialize消息。由于此方法遵从普通的覆写规则，通常应该
  在里面判断当前要初始化的是哪个类
3. load和initialize方法都应该实现得精简一些，这有助于保持应用程序的响应能力，也能减少引入
  依赖环的几率
4. 无法在编译期设定的全局变量，可以放在initialize方法里来初始化

## 52 别忘了NSTimer会保留其目标对象

1. NSTimer对象会保留其目标，直到计时器本身失效为止，调用invalidate方法可令计时器失效，另外，
  一次性的计时器在触发完任务之后也会失效
2. 反复执行任务的计时器，很容易引入保留环，如果计时器的目标对象又保留了计时器本身，那肯定会
  导致保留环。可能是直接产生也可能是间接产生。
3. 可以扩充NSTimer的功能，用块来打破保留环。不过除非NSTimer未来提供公共接口，否则必须创建
  NSTimer的分类，将相关代码加入其中



---
The End.

zhlinh

Email: zhlinhng@gmail.com

2019-10-03
